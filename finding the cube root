def nth_root(a, n, tolerance=1e-10, max_iterations=100):
    """
    Calculate the nth root of a number using the Newton-Raphson method.
    
    Parameters:
    a (float): The number to find the nth root of (must be non-negative if n is even).
    n (int): The root (e.g., 2 for square root, 3 for cube root).
    tolerance (float): The precision threshold for convergence.
    max_iterations (int): Maximum number of iterations to prevent infinite loops.
    
    Returns:
    float: The nth root of a.
    """
    if a < 0 and n % 2 == 0:
        raise ValueError("Cannot compute even root of a negative number")
    if n == 0:
        raise ValueError("Root cannot be zero")
    
    # Initial guess: Use a/2 for simplicity
    x = a / 2 if a != 0 else 1
    
    for _ in range(max_iterations):
        # Newton-Raphson update: x = x - (x^n - a)/(n * x^(n-1))
        next_x = x - (x**n - a) / (n * x**(n-1))
        
        # Check for convergence
        if abs(next_x - x) < tolerance:
            return next_x
        x = next_x
    
    return x  # Return the best approximation



#finding euclidean distance 
def euclidean_distance(x1, y1, x2, y2):
    """
    Calculate the Euclidean distance between two points in a 2D plane.
    
    Parameters:
    x1, y1 (float): Coordinates of the first point.
    x2, y2 (float): Coordinates of the second point.
    
    Returns:
    float: The Euclidean distance between the two points.
    """
    return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5

# Test the nth_root function
print(nth_root(16, 2))  # Should output approximately 4.0 (square root)
print(nth_root(27, 3))  # Should output approximately 3.0 (cube root)

# Test the euclidean_distance function
print(euclidean_distance(0, 0, 3, 4))  # Should output 5.0
print(euclidean_distance(1, 1, 4, 5))  # Should output 5.0